{"ast":null,"code":"import _toConsumableArray from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/node_modules/@babel/runtime/helpers/esm/inherits\";\nvar _jsxFileName = \"/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/src/components/Pagination.js\";\nimport React, { Component, Fragment } from \"react\";\nimport PropTypes from \"prop-types\"; //These constants will be used to indicate points where we have page controls for moving left and right respectively.\n\nvar LEFT_PAGE = \"LEFT\";\nvar RIGHT_PAGE = \"RIGHT\"; // W create a helped method for creating a range of numbers\n\nvar range = function range(from, to) {\n  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var i = from;\n  var range = [];\n\n  while (i <= to) {\n    range.push(i);\n    i += step;\n  }\n\n  return range;\n};\n\nvar Pagination =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Pagination, _Component);\n\n  function Pagination(props) {\n    var _this;\n\n    _classCallCheck(this, Pagination);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pagination).call(this, props));\n\n    _this.goToPage = function (page) {\n      var _this$props$onPageCha = _this.props.onPageChanged,\n          onPageChanged = _this$props$onPageCha === void 0 ? function (f) {\n        return f;\n      } : _this$props$onPageCha;\n      var currentPage = Math.max(0, Math.min(page, _this.totalPages));\n      var paginationData = {\n        currentPage: currentPage,\n        totalPage: _this.totalPages,\n        pageLimit: _this.pageLimit,\n        totalRecords: _this.totalRecords\n      };\n\n      _this.setState({\n        currentPage: currentPage\n      }, function () {\n        return onPageChanged(paginationData);\n      });\n    };\n\n    _this.handleClick = function (page) {\n      return function (evt) {\n        evt.preventDefault();\n\n        _this.goToPage(page);\n      };\n    };\n\n    _this.handleMoveLeft = function (evt) {\n      evt.preventDefault();\n\n      _this.goToPage(_this.state.currentPage - _this.pageNeighbours * 2 - 1);\n    };\n\n    _this.handleMoveRight = function (evt) {\n      evt.preventDefault();\n\n      _this.goToPage(_this.state.currentPage + _this.pageNeighbours * 2 + 1);\n    };\n\n    _this.fetchPageNumbers = function () {\n      var totalPages = _this.totalPages;\n      var currentPage = _this.state.currentPage;\n      var pageNeighbours = _this.pageNeighbours;\n      /**\n       * totalNumbers: the total page numbers to show on the control\n       * totalBlocks: totalNumbers + 2 to cover for the left(<) and right(>) controls\n       */\n\n      var totalNumbers = _this.pageNeighbours * 2 + 3;\n      var totalBlocks = totalNumbers + 2;\n\n      if (totalPages > totalBlocks) {\n        var startPage = Math.max(2, currentPage - pageNeighbours);\n        var endPage = Math.min(totalPages - 1, currentPage + pageNeighbours);\n        var pages = range(startPage, endPage);\n        /**\n         * hasLeftSpill: has hidden pages to the left\n         * hasRightSpill: has hidden pages to the right\n         * spillOffset: number of hidden pages either to the left or to the right\n         */\n\n        var hasLeftSpill = startPage > 2;\n        var hasRightSpill = totalPages - endPage > 1;\n        var spillOffset = totalNumbers - (pages.length + 1);\n\n        switch (true) {\n          // handle: (1) < {5 6} [7] {8 9} (10)\n          case hasLeftSpill && !hasRightSpill:\n            {\n              var extraPages = range(startPage - spillOffset, startPage - 1);\n              pages = [LEFT_PAGE].concat(_toConsumableArray(extraPages), _toConsumableArray(pages));\n              break;\n            }\n          // handle: (1) {2 3} [4] {5 6} > (10)\n\n          case !hasLeftSpill && hasRightSpill:\n            {\n              var _extraPages = range(endPage + 1, endPage + spillOffset);\n\n              pages = [].concat(_toConsumableArray(pages), _toConsumableArray(_extraPages), [RIGHT_PAGE]);\n              break;\n            }\n          // handle: (1) < {4 5} [6] {7 8} > (10)\n\n          case hasLeftSpill && hasRightSpill:\n          default:\n            {\n              pages = [LEFT_PAGE].concat(_toConsumableArray(pages), [RIGHT_PAGE]);\n              break;\n            }\n        }\n\n        return [1].concat(_toConsumableArray(pages), [totalPages]);\n      }\n\n      return range(1, totalPages);\n    };\n\n    var _props$totalRecords = props.totalRecords,\n        totalRecords = _props$totalRecords === void 0 ? null : _props$totalRecords,\n        _props$pageLimit = props.pageLimit,\n        pageLimit = _props$pageLimit === void 0 ? 30 : _props$pageLimit,\n        _props$pageNeighbours = props.pageNeighbours,\n        _pageNeighbours = _props$pageNeighbours === void 0 ? 0 : _props$pageNeighbours;\n\n    _this.pageLimit = typeof pageLimit === \"number\" ? pageLimit : 30; // number of records to be show per page\n\n    _this.totalRecords = typeof totalRecords === \"number\" ? totalRecords : 0; // total number of records to be paginated. Comes from API call.\n\n    _this.pageNeighbours = typeof _pageNeighbours === \"number\" ? Math.max(0, Math.min(_pageNeighbours, 2)) : 0; // total page neighbours (show in component)\n\n    _this.totalPages = Math.ceil(_this.totalRecords / _this.pageLimit); // total pages to be shown, used math.ceil to capture excess records on last page.\n\n    _this.state = {\n      currentPage: 1\n    };\n    return _this;\n  }\n\n  _createClass(Pagination, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.goToPage(1);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      console.log(this.totalRecords);\n      if (!this.totalRecords || this.totalPages === 1) return null;\n      var currentPage = this.state.currentPage;\n      var pages = this.fetchPageNumbers();\n      return React.createElement(Fragment, {\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 146\n        },\n        __self: this\n      }, React.createElement(\"div\", {\n        className: \"ui pagination menu\",\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 147\n        },\n        __self: this\n      }, pages.map(function (page, index) {\n        if (page === LEFT_PAGE) return React.createElement(\"a\", {\n          className: \"active item\",\n          onClick: _this2.handleMoveLeft,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 151\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          \"aria-hidden\": true,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 152\n          },\n          __self: this\n        }, \"\\xAB\"), React.createElement(\"span\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 153\n          },\n          __self: this\n        }, \"Previous\"));\n        if (page === RIGHT_PAGE) return React.createElement(\"a\", {\n          className: \"active item\",\n          onClick: _this2.handleMoveRight,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 159\n          },\n          __self: this\n        }, React.createElement(\"span\", {\n          \"aria-hidden\": true,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 160\n          },\n          __self: this\n        }, \"\\xBB\"), React.createElement(\"span\", {\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 161\n          },\n          __self: this\n        }, \"Next\"));\n        return React.createElement(\"a\", {\n          className: \"\".concat(currentPage === page ? \"active \" : \"\", \"item\"),\n          onClick: _this2.handleClick(page),\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 166\n          },\n          __self: this\n        }, page, \">\");\n      })));\n    }\n  }]);\n\n  return Pagination;\n}(Component); // this is where we specify the TYPE of prop that is passed to the components. This is used above when calling \"typeof\" which verifies that what is received, is what is\n// expected from the prop.\n\n\nPagination.propTypes = {\n  totalRecords: PropTypes.number.isRequired,\n  pageLimit: PropTypes.number,\n  pageNeighbours: PropTypes.number,\n  onPageChanged: PropTypes.func\n};\nexport default Pagination;","map":{"version":3,"sources":["/Users/kylewiltshire/Documents/projects/2019/Javascript/playground/monten/client/src/components/Pagination.js"],"names":["React","Component","Fragment","PropTypes","LEFT_PAGE","RIGHT_PAGE","range","from","to","step","i","push","Pagination","props","goToPage","page","onPageChanged","f","currentPage","Math","max","min","totalPages","paginationData","totalPage","pageLimit","totalRecords","setState","handleClick","evt","preventDefault","handleMoveLeft","state","pageNeighbours","handleMoveRight","fetchPageNumbers","totalNumbers","totalBlocks","startPage","endPage","pages","hasLeftSpill","hasRightSpill","spillOffset","length","extraPages","ceil","console","log","map","index","propTypes","number","isRequired","func"],"mappings":"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","sourcesContent":["import React, { Component, Fragment } from \"react\";\nimport PropTypes from \"prop-types\";\n\n//These constants will be used to indicate points where we have page controls for moving left and right respectively.\nconst LEFT_PAGE = \"LEFT\";\nconst RIGHT_PAGE = \"RIGHT\";\n\n// W create a helped method for creating a range of numbers\nconst range = (from, to, step = 1) => {\n  let i = from;\n  const range = [];\n\n  while (i <= to) {\n    range.push(i);\n    i += step;\n  }\n\n  return range;\n};\n\nclass Pagination extends Component {\n  constructor(props) {\n    super(props);\n    const { totalRecords = null, pageLimit = 30, pageNeighbours = 0 } = props;\n\n    this.pageLimit = typeof pageLimit === \"number\" ? pageLimit : 30; // number of records to be show per page\n    this.totalRecords = typeof totalRecords === \"number\" ? totalRecords : 0; // total number of records to be paginated. Comes from API call.\n    this.pageNeighbours =\n      typeof pageNeighbours === \"number\"\n        ? Math.max(0, Math.min(pageNeighbours, 2))\n        : 0; // total page neighbours (show in component)\n    this.totalPages = Math.ceil(this.totalRecords / this.pageLimit); // total pages to be shown, used math.ceil to capture excess records on last page.\n    this.state = { currentPage: 1 };\n  }\n\n  componentDidMount() {\n    this.goToPage(1);\n  }\n\n  goToPage = page => {\n    const { onPageChanged = f => f } = this.props;\n    const currentPage = Math.max(0, Math.min(page, this.totalPages));\n\n    const paginationData = {\n      currentPage,\n      totalPage: this.totalPages,\n      pageLimit: this.pageLimit,\n      totalRecords: this.totalRecords\n    };\n\n    this.setState({ currentPage }, () => onPageChanged(paginationData));\n  };\n\n  handleClick = page => evt => {\n    evt.preventDefault();\n    this.goToPage(page);\n  };\n\n  handleMoveLeft = evt => {\n    evt.preventDefault();\n    this.goToPage(this.state.currentPage - this.pageNeighbours * 2 - 1);\n  };\n\n  handleMoveRight = evt => {\n    evt.preventDefault();\n    this.goToPage(this.state.currentPage + this.pageNeighbours * 2 + 1);\n  };\n\n  /**\n   * Let's say we have 10 pages and we set pageNeighbours to 2\n   * Given that the current page is 6\n   * The pagination control will look like the following:\n   *\n   * (1) < {4 5} [6] {7 8} > (10)\n   *\n   * (x) => terminal pages: first and last page(always visible)\n   * [x] => represents current page\n   * {...x} => represents page neighbours\n   */\n\n  // This method handles the core logic for generating the page numbers to be shown on the pagination control. We want the first page and last page to always be visible.\n  fetchPageNumbers = () => {\n    const totalPages = this.totalPages;\n    const currentPage = this.state.currentPage;\n    const pageNeighbours = this.pageNeighbours;\n\n    /**\n     * totalNumbers: the total page numbers to show on the control\n     * totalBlocks: totalNumbers + 2 to cover for the left(<) and right(>) controls\n     */\n\n    const totalNumbers = this.pageNeighbours * 2 + 3;\n    const totalBlocks = totalNumbers + 2;\n\n    if (totalPages > totalBlocks) {\n      const startPage = Math.max(2, currentPage - pageNeighbours);\n      const endPage = Math.min(totalPages - 1, currentPage + pageNeighbours);\n\n      let pages = range(startPage, endPage);\n\n      /**\n       * hasLeftSpill: has hidden pages to the left\n       * hasRightSpill: has hidden pages to the right\n       * spillOffset: number of hidden pages either to the left or to the right\n       */\n\n      const hasLeftSpill = startPage > 2;\n      const hasRightSpill = totalPages - endPage > 1;\n      const spillOffset = totalNumbers - (pages.length + 1);\n\n      switch (true) {\n        // handle: (1) < {5 6} [7] {8 9} (10)\n        case hasLeftSpill && !hasRightSpill: {\n          const extraPages = range(startPage - spillOffset, startPage - 1);\n          pages = [LEFT_PAGE, ...extraPages, ...pages];\n          break;\n        }\n        // handle: (1) {2 3} [4] {5 6} > (10)\n        case !hasLeftSpill && hasRightSpill: {\n          const extraPages = range(endPage + 1, endPage + spillOffset);\n          pages = [...pages, ...extraPages, RIGHT_PAGE];\n          break;\n        }\n        // handle: (1) < {4 5} [6] {7 8} > (10)\n        case hasLeftSpill && hasRightSpill:\n        default: {\n          pages = [LEFT_PAGE, ...pages, RIGHT_PAGE];\n          break;\n        }\n      }\n\n      return [1, ...pages, totalPages];\n    }\n\n    return range(1, totalPages);\n  };\n\n  render() {\n    console.log(this.totalRecords);\n    if (!this.totalRecords || this.totalPages === 1) return null;\n\n    const { currentPage } = this.state;\n    const pages = this.fetchPageNumbers();\n\n    return (\n      <Fragment>\n        <div className=\"ui pagination menu\">\n          {pages.map((page, index) => {\n            if (page === LEFT_PAGE)\n              return (\n                <a className=\"active item\" onClick={this.handleMoveLeft}>\n                  <span aria-hidden>&laquo;</span>\n                  <span>Previous</span>\n                </a>\n              );\n\n            if (page === RIGHT_PAGE)\n              return (\n                <a className=\"active item\" onClick={this.handleMoveRight}>\n                  <span aria-hidden>&raquo;</span>\n                  <span>Next</span>\n                </a>\n              );\n\n            return (\n              <a\n                className={`${currentPage === page ? \"active \" : \"\"}item`}\n                onClick={this.handleClick(page)}\n              >\n                {page}>\n              </a>\n            );\n          })}\n        </div>\n      </Fragment>\n    );\n  }\n}\n\n// this is where we specify the TYPE of prop that is passed to the components. This is used above when calling \"typeof\" which verifies that what is received, is what is\n// expected from the prop.\nPagination.propTypes = {\n  totalRecords: PropTypes.number.isRequired,\n  pageLimit: PropTypes.number,\n  pageNeighbours: PropTypes.number,\n  onPageChanged: PropTypes.func\n};\n\nexport default Pagination;\n"]},"metadata":{},"sourceType":"module"}